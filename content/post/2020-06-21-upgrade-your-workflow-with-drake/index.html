---
title: Upgrade your workflow with drake
author: ~
date: '2020-06-21'
slug: upgrade-your-workflow-with-drake
tags:
    - R
images: ["/img/drake-model-execution-plan.png"]
featuredalt: "A drake model execution plan"

---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>


<p>Drake is my new favourite R package.</p>
<p>Drake is a tool for orchestrating complicated workflows. You piece together a plan based on some high-level, abstract functions. These functions should be <em>pure</em> — they need to be defined by their inputs only, not relying on any predefined variables that aren’t in the function signature. Then, drake will take the steps in that plan and work out how to run it. Here’s how I’ve defined the plan above:</p>
<pre class="r"><code>drake::drake_plan(
  new_data = new_data_to_be_scored(),
  tfidf = readr::read_rds(file_in(&quot;artefacts/tfidf.rds&quot;)),
  vectoriser = readr::read_rds(file_in(&quot;artefacts/vectoriser.rds&quot;)),
  review_rf = readr::read_rds(file_in(&quot;artefacts/review_rf.rds&quot;)),
  predictions = sentiment(new_data$review,
                          random_forest = review_rf,
                          vectoriser = vectoriser,
                          tfidf = tfidf),
  validation = validate_predictions(predictions),
  submit_predictions = target(
    submit_predictions(predictions),
    trigger = trigger(condition = validation, mode = &quot;blacklist&quot;)
  )
)</code></pre>
<p>Drake is magic. I’m not going to go through the intricacies of this plan or how drake works, since <a href="https://books.ropensci.org/drake/">the drake documentation is some of the best I’ve ever seen for an R package</a>. But here are some reasons to use drake:</p>
<ol style="list-style-type: decimal">
<li>It doesn’t matter what order you declare the steps, as drake is smart enough to determine the dependencies between them.</li>
<li>If you change something in a step halfway through the plan, drake will work out what needs to be rerun and only rerun that. Drake frees you from having to work out what parts of your code you need to execute when you make a change.</li>
<li>You’ll never need a directory of files with names like “01-setup.R”, “02-source-data.R”, etc. ever again.</li>
<li>Drake can work out which steps of your plan can be parallelised, and makes it easier to do so.</li>
<li>You’ll be encouraged to think about your project execution in terms of <em>pure functions</em>. R is idiomatically a functional language, and that’s the style that makes drake work.</li>
</ol>
<p>I came across this powerful package when I was researching best practices for R. I wanted to see if I could fit drake into some sort of standardised approach to training and implementing a machine learning model.</p>
<div id="project-workflows" class="section level2">
<h2>Project workflows</h2>
<p>When it comes to code, there are three major components to a machine learning project:</p>
<ol style="list-style-type: decimal">
<li>Exploratory data analysis (EDA)</li>
<li>Model training</li>
<li>Model execution</li>
</ol>
<p>These components are run independently of each other. EDA is a largely human task, and is usually only performed when the model is created or updated in some major way. The other two components need not operate together — if model retraining is expensive, or new training data is infrequently available, we might retrain a model on some monthly basis while scoring new data on a daily basis.</p>
<p>I pieced together <a href="https://github.com/mdneuzerling/DrakeModelling">a template</a> that implements these three components using R-specific tools:</p>
<ol style="list-style-type: decimal">
<li>EDA — <strong>R Markdown</strong></li>
<li>Model training — <strong>drake</strong></li>
<li>Model execution — <strong>drake</strong></li>
</ol>
<p>All three of these components might use similar functions. Typically we would place all of these functions in a directory (almost always called <code>R/</code>) and <code>source</code> them as needed. Here I want to try to combine these components into a custom R package.</p>
<p>R packages are the standard for complicated R projects. With packages, we gain access to the comprehensive <code>R CMD CHECK</code>, as well as <code>testthat</code> unit tests and <code>roxygen2</code> documentation. I’m certainly not the first to combine drake with a package workflow, but I wanted to have a single repository that combines all elements of a machine learning project.</p>
<p>This template uses a simple random forest sentiment analysis model, based on <a href="https://archive.ics.uci.edu/ml/datasets/Sentiment+Labelled+Sentences">labelled data available from the UCI machine learning repository</a>. Drake takes care of the data caching for us. This means that we can, say, adjust the hyper-parameters of our model and rerun the training plan, and only the modelling step and onward will be rerun.</p>
<p>This template considers machine learning workflows intended to be executed in batch — for models that run as APIs, consider using <code>plumber</code> instead.</p>
</div>
<div id="training-and-execution" class="section level2">
<h2>Training and execution</h2>
<p>After cloning the repo, navigate to the directory in which the files are located. The easiest way to do this is to open the project in RStudio.</p>
<p>Model training and execution plans are generated by functions in the package. The package doesn’t actually need to be installed — we can use <code>devtools::load_all()</code> to simulate the installation. The model can be trained with:</p>
<pre class="r"><code>devtools::load_all()
drake::make(model_training_plan())</code></pre>
<p>Plot the plan with <code>drake::vis_drake_graph</code>:</p>
<p><img src="drake-model-training-plan.png" /></p>
<p>Model execution is run similarly:</p>
<pre class="r"><code>devtools::load_all()
drake::make(model_execution_plan())</code></pre>
<p>Model artefacts — the random forest model, the vectoriser, and the tfidf weightings — are saved to and loaded from the <code>artefacts</code> directory. This is an arbitrary choice. We could just as easily use a different directory or remote storage.</p>
<p>I’ve simulated a production step with a <code>new_data_to_be_scored</code> function that returns a few reviews to be scored. Predictions are “submitted” through the <code>submit_prediction()</code> function. This function does nothing except sleep for 5 seconds. In practice we would submit model output wherever it needs to go — locally, a cloud service, etc. It’s hard to “productionise” a model when it’s just a toy.</p>
<p>The exploratory data analysis piece can be found in the <code>inst/eda/</code> directory. It’s a standard R Markdown file, and can be compiled with <code>knitr</code>.</p>
</div>
<div id="model-and-prediction-verification" class="section level2">
<h2>Model and prediction verification</h2>
<p>Both training and execution plans include a <em>verification</em> step. These are functions that — using the <code>assertthat</code> package — ensure certain basic facts about the model and its predictions are true. If any of these assertions is false, an error is returned.</p>
<pre class="r"><code>validate_model &lt;- function(random_forest, vectoriser, tfidf = NULL) {
  model_sentiment &lt;- function(x) sentiment(x, random_forest, vectoriser, tfidf)
  oob &lt;- random_forest$err.rate[random_forest$ntree, &quot;OOB&quot;] # out of bag error

  assertthat::assert_that(model_sentiment(&quot;love&quot;) == &quot;good&quot;)
  assertthat::assert_that(model_sentiment(&quot;bad&quot;) == &quot;bad&quot;)
  assertthat::assert_that(oob &lt; 0.4)

  TRUE
}</code></pre>
<p>The model artefacts and predictions cannot be exported without passing this verification step. Their relevant drake targets are conditioned on the validation function returning <code>TRUE</code>:</p>
<pre class="r"><code>output_model = drake::target(
  {
    dir.create(&quot;artefacts&quot;, showWarnings = FALSE)
    readr::write_rds(vectoriser, file_out(&quot;artefacts/vectoriser.rds&quot;))
    readr::write_rds(tfidf, file_out(&quot;artefacts/tfidf.rds&quot;))
    readr::write_rds(review_rf, file_out(&quot;artefacts/review_rf.rds&quot;))
  },
  trigger = drake::trigger(condition = validation, mode = &quot;blacklist&quot;)
)</code></pre>
<p>For example, suppose I changed the assertion above to demand that my model must have an out-of-bag error of less than 0.01% before it can be exported. My model isn’t very good, however, so that step will error. The execution steps are dependent on that validation, and so they won’t be run.</p>
<p><img src="failed-validation.png" /></p>
<p>The assertions I’ve included here are very basic. However, I think these steps of the plans are important and extensible. We could assert that a model:</p>
<ul>
<li>produces sensible outputs, based on type or domain.</li>
<li>has an accuracy above a given threshold, based on one or more metrics.</li>
<li>does not produce outputs that are biased against a particular group.</li>
</ul>
<p>We could also assert that predictions of new data:</p>
<ul>
<li>are sensible.</li>
<li>do not contain sensitive data.</li>
<li>are not biased against particular groups.</li>
</ul>
</div>
<div id="not-the-best-practice" class="section level2">
<h2>Not the best practice</h2>
<p>If you’re interested, <a href="https://github.com/mdneuzerling/DrakeModelling">I’ve put the template up as a git repository</a>, <code>DrakeModelling</code>.</p>
<p>This wasn’t my first attempt to template a machine learning workflow. Before I discovered drake I tried to structure <a href="https://github.com/mdneuzerling/ModelAsAPackage">a model as a package</a> such that <em>installing the package was the same as training the model</em>. I did this by having a vignette for model training, which inserted artefacts into the package.</p>
<p>It’s a pretty fun way to train a model. Imagine installing a package and triggering a 12-hour model training process? But it’s not a very clean approach. Hadley said it was like “fixing the plane while flying it”, and he wasn’t wrong.</p>
<hr />
<pre class="r"><code>devtools::session_info()</code></pre>
<pre><code>## ─ Session info ───────────────────────────────────────────────────────────────
##  setting  value                       
##  version  R version 4.1.0 (2021-05-18)
##  os       macOS Big Sur 11.3          
##  system   aarch64, darwin20           
##  ui       X11                         
##  language (EN)                        
##  collate  en_AU.UTF-8                 
##  ctype    en_AU.UTF-8                 
##  tz       Australia/Melbourne         
##  date     2021-05-30                  
## 
## ─ Packages ───────────────────────────────────────────────────────────────────
##  package     * version date       lib source        
##  blogdown      1.3     2021-04-14 [1] CRAN (R 4.1.0)
##  bookdown      0.22    2021-04-22 [1] CRAN (R 4.1.0)
##  bslib         0.2.5.1 2021-05-18 [1] CRAN (R 4.1.0)
##  cachem        1.0.4   2021-02-13 [1] CRAN (R 4.1.0)
##  callr         3.7.0   2021-04-20 [1] CRAN (R 4.1.0)
##  cli           2.5.0   2021-04-26 [1] CRAN (R 4.1.0)
##  crayon        1.4.1   2021-02-08 [1] CRAN (R 4.1.0)
##  desc          1.3.0   2021-03-05 [1] CRAN (R 4.1.0)
##  devtools      2.4.0   2021-04-07 [1] CRAN (R 4.1.0)
##  digest        0.6.27  2020-10-24 [1] CRAN (R 4.1.0)
##  ellipsis      0.3.2   2021-04-29 [1] CRAN (R 4.1.0)
##  evaluate      0.14    2019-05-28 [1] CRAN (R 4.1.0)
##  fastmap       1.1.0   2021-01-25 [1] CRAN (R 4.1.0)
##  fs            1.5.0   2020-07-31 [1] CRAN (R 4.1.0)
##  glue          1.4.2   2020-08-27 [1] CRAN (R 4.1.0)
##  htmltools     0.5.1.1 2021-01-22 [1] CRAN (R 4.1.0)
##  jquerylib     0.1.4   2021-04-26 [1] CRAN (R 4.1.0)
##  jsonlite      1.7.2   2020-12-09 [1] CRAN (R 4.1.0)
##  knitr         1.33    2021-04-24 [1] CRAN (R 4.1.0)
##  lifecycle     1.0.0   2021-02-15 [1] CRAN (R 4.1.0)
##  magrittr      2.0.1   2020-11-17 [1] CRAN (R 4.1.0)
##  memoise       2.0.0   2021-01-26 [1] CRAN (R 4.1.0)
##  pkgbuild      1.2.0   2020-12-15 [1] CRAN (R 4.1.0)
##  pkgload       1.2.1   2021-04-06 [1] CRAN (R 4.1.0)
##  prettyunits   1.1.1   2020-01-24 [1] CRAN (R 4.1.0)
##  processx      3.5.2   2021-04-30 [1] CRAN (R 4.1.0)
##  ps            1.6.0   2021-02-28 [1] CRAN (R 4.1.0)
##  purrr         0.3.4   2020-04-17 [1] CRAN (R 4.1.0)
##  R6            2.5.0   2020-10-28 [1] CRAN (R 4.1.0)
##  remotes       2.3.0   2021-04-01 [1] CRAN (R 4.1.0)
##  rlang         0.4.11  2021-04-30 [1] CRAN (R 4.1.0)
##  rmarkdown     2.8     2021-05-07 [1] CRAN (R 4.1.0)
##  rprojroot     2.0.2   2020-11-15 [1] CRAN (R 4.1.0)
##  sass          0.4.0   2021-05-12 [1] CRAN (R 4.1.0)
##  sessioninfo   1.1.1   2018-11-05 [1] CRAN (R 4.1.0)
##  stringi       1.6.1   2021-05-10 [1] CRAN (R 4.1.0)
##  stringr       1.4.0   2019-02-10 [1] CRAN (R 4.1.0)
##  testthat      3.0.2   2021-02-14 [1] CRAN (R 4.1.0)
##  usethis       2.0.1   2021-02-10 [1] CRAN (R 4.1.0)
##  withr         2.4.2   2021-04-18 [1] CRAN (R 4.1.0)
##  xfun          0.22    2021-03-11 [1] CRAN (R 4.1.0)
##  yaml          2.2.1   2020-02-01 [1] CRAN (R 4.1.0)
## 
## [1] /Library/Frameworks/R.framework/Versions/4.1-arm64/Resources/library</code></pre>
</div>
